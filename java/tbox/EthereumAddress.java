package tbox;

// See:
// https://ethereum.stackexchange.com/questions/3542/
//   how-are-ethereum-addresses-generated/3619#3619

public class EthereumAddress
{
  private ECKeyPair keypair_;

  public EthereumAddress( byte[] pvkey ) throws Exception
  {
    keypair_ = new ECKeyPair( pvkey );

    // ensure we're configured to use uncompressed keys
    byte[] pubkey = keypair_.publickey();
    if (pubkey.length != 65 || pubkey[0] != (byte)0x04)
      throw new Exception( "Invalid public key format: " +
                           HexString.encode(pubkey) );
  }

  public String toString()
  {
    try {
      byte[] pubkey64 = ByteOps.dropFirstByte( keypair_.publickey() );
      byte[] hashed = Keccak256.hash( pubkey64 );
      byte[] resultbytes = java.util.Arrays.copyOfRange( hashed, 12, 32 );
      return "0x" + HexString.encode( resultbytes );
    } catch( Exception e ) {}

    return "";
  }

  // Test --------------------------------------------------------------------
  // test vectors generated by ttp://www.ethersecret.com/
  public static void main( String[] args ) throws Exception
  {
    String[] privatekeys = {
      "dc6079feb7d962b40af3fef7b9a426b27f46b2b75212512b7a46b18440a038c8",
      "57adfcdc5396116eb0978fc6b2cfa7ac73de544e6055d822269a172691be82fe",
      "e4dde9cef933177eba9ce7fb0440207c6424b48bd73e17f7594b7b8fd6e6a78a"
    };

    String[] addresses = {
      "0xFe2E3C67434288f6cB866dC52034e09618FF442d",
      "0xA79837F8E6E737454361F3E839788d4CFe3bd7f3",
      "0xD703242D8BE8646b0Cd5456cF2D4E260e69e0fA7"
    };

    for (int ii = 0; ii < privatekeys.length; ii++)
    {
      EthereumAddress ea =
        new EthereumAddress( HexString.decode(privatekeys[ii]) );

      if ( !ea.toString().equalsIgnoreCase(addresses[ii]) )
        throw new Exception( "Expected: " + addresses[ii] +
                             " got: " + ea.toString() );
    }

    System.out.println( "EthereumAddress: PASS" );
  }
}
